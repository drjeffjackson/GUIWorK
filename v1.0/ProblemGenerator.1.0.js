// 1.0 version of ProblemGenerator.js

var A_CODE = 'a'.charCodeAt();

// Construct and display a string of PGML code representing the
// questions entered on a web page.
function generatePGML(button)
{
  // TERMINOLOGY NOTE: A "problem" to WeBWorK is a set of questions.
  // But when I coded this, I thought of each question as a problem.
  // TODO: Should refactor the terminology...

  // Initialize problem references
  var questionDiv = document.getElementById("questionDiv");
  var problems = questionDiv.getElementsByTagName("form");
  var numProblems = problems.length;

  // Add PG preamble to output string.
  var outString = "";
  outString += '############## Generated by GUIWorK ############## \n';
  outString += '#  Note that if any changes are made directly    # \n';
  outString += '#  to the PG code below then the GUIWorK editor  # \n';
  outString += '#  cannot be used to update this problem.        # \n';
  outString += '################################################## \n';
  outString += 'DOCUMENT(); \n';
  outString += 'loadMacros( \n';
  outString += '"PGstandard.pl", \n';
  outString += '"MathObjects.pl", \n';
  outString += '"PGchoicemacros.pl", \n';
  outString += '"parserRadioButtons.pl", \n';
  outString += '"PGML.pl"); \n';
  outString += ' \n';

  // Add each problem's initialization to the output string
  for (nProblem = 1; nProblem <= numProblems; nProblem++) {

    var problem = problems[nProblem-1];
    var radioObject = '$radio' + nProblem;
    outString += '# INITIALIZATION FOR PROBLEM ' + nProblem + '\n';
    outString += radioObject +' = RadioButtons( \n';
    outString += '  [ \n';
    answerBoxes = problem.getElementsByClassName("inBox");
    answerStrings = new Array();
    for (i=0; i<answerBoxes.length; i++) {
      answerStrings[i] =
        encodeQuotes(encodeLaTeXMathModePG(answerBoxes[i].value));
    }
    for (i=0; i<answerBoxes.length; i++) {
      outString += '    "' + answerStrings[i] +'", \n';
    }
    outString += '  ], \n';
    var selectAnswer = problem.getElementsByClassName("selectAnswer")[0];
//    if (correctAnswer.startsWith("Select")) {
    if (selectAnswer.selectedIndex == 0) {
      window.alert("Must select an answer for Question " + nProblem);
      return false;
    }
    var correctAnswer = selectAnswer.value;
    outString += 
      '  "' + answerStrings[correctAnswer.charCodeAt()-A_CODE] + '", \n';
    outString += '  order=>[ \n';
    for (i=0; i<answerBoxes.length; i++) {
      outString += '    "' + answerStrings[i] +'", \n';
    }
    outString += '  ] \n';
    outString += '); \n';
  }

  // Begin the PGML section
  outString += '\n';
  outString += 'TEXT(beginproblem()); \n';
  outString += 'BEGIN_PGML \n';
  outString += '=== \n';

  // Add each problem's PGML code to the output string
  for (nProblem = 1; nProblem <= numProblems; nProblem++) {
    var problem = problems[nProblem-1];
    var question = problem.getElementsByClassName("question")[0];
    var radioObject = '$radio' + nProblem;
    outString += '  \n';
    outString += '*Question ' + nProblem + '*  \n'; // need exactly 2 spaces
    outString += encodeLaTeXMathModePGML(question.value) + '\n  \n';
    outString += '[@ ANS(' + radioObject + '->cmp); ' 
    	         + radioObject + '->buttons(); @]*\n';
  }
  // Close PGML section
  outString += '\n';
  outString += 'END_PGML \n';

  // Include any solutions
  var someSolution = false;
  for (nProblem = 1; nProblem <= numProblems; nProblem++) {
    var problem = problems[nProblem-1];
    var solution = problem.getElementsByClassName("solution")[0];
    if (solution.value) {
      if (!someSolution) {
        outString += '\n';
        outString += 'BEGIN_PGML_SOLUTION \n';
	someSolution = true;
      }
      outString += '\n';
      outString += '*Question ' + nProblem + '*  \n';
      outString += encodeLaTeXMathModePGML(solution.value) + ' \n';
    }
  }
  if (someSolution) {
    outString += '\n';
    outString += 'END_PGML_SOLUTION \n';
  }

  // Terminate the PG code
  outString += 'ENDDOCUMENT(); \n';

  // Append HTML representing the entire page, including input values
  // (except anything in the outBox textarea)
  // so that the problem can be edited later.
  // This modifies the document to include the input values.
  outString += '<!-- \n';
  outString += '############## Generated by GUIWorK ############## \n';
  outString += '#  The following code is ignored by WeBWorK      # \n';
  outString += '#  and can be deleted if you do not plan to use  # \n';
  outString += '#  the GUIWorK editor to update this problem.    # \n';
  outString += '################################################## \n';
  outString += '--> \n';
  addInputValues(document.documentElement);
  var outBox = document.getElementById("outBox");
  outBox.textContent = "";  
  outString += document.documentElement.outerHTML + '\n';

  // Display the PGML+HTML code in the appropriate textarea
  outBox.value = outString;

  return false;
}

// Add an answer box following the current answer box.
function addAnswer(textBox)
{
  // Retrieve pointers to the current answer paragraph,
  // the div containing all answers, and
  // the fieldset of the form containing this problem.
  var paragraph = textBox.parentNode;
  var answerDiv = paragraph.parentNode;
  var fieldset = answerDiv.parentNode;

  // Create the new answer box as a copy of the current one
  // and insert it following the current answer box.
  var newAnswer = document.createElement("p");
  answerDiv.insertBefore(newAnswer, paragraph.nextSibling);
  newAnswer.innerHTML = paragraph.innerHTML;

  // Clear the box (input element might have value attribute set).
  var input = newAnswer.getElementsByClassName("inBox")[0];
  input.value = '';

  // Increment the newly created answer's letter as well as
  // the letters of all subsequent answers.
  var nextNode = newAnswer;
  do {
    if (nextNode.nodeType == Node.ELEMENT_NODE) {
       var letterSpan = nextNode.getElementsByClassName("letter")[0];
       letterSpan.textContent = nextLetter(letterSpan.textContent);
    }
    nextNode = nextNode.nextSibling;
  } while (nextNode);

  // Add an option to the correct-answer select menu
  var selectAnswer = fieldset.getElementsByClassName("selectAnswer")[0];
  var options = selectAnswer.getElementsByTagName("option");
  var nOptions = options.length-1; // first "option" is disabled
  var newOptionText = String.fromCharCode(A_CODE+nOptions) + ".";
  var newOption = document.createElement("option");
  selectAnswer.appendChild(newOption);
  newOption.textContent = newOptionText;
}

// Delete the current answer box.
function delAnswer(textBox)
{
  // Retrieve pointers to the current answer paragraph,
  // the div containing all answers, 
  // the fieldset of the form containing this problem,
  // the next sibling following this answer paragraph,
  // the select containing the possible answer letters,
  // and the options within the select.
  var paragraph = textBox.parentNode;
  var answerDiv = paragraph.parentNode;
  var fieldset = answerDiv.parentNode;
  var nextNode = paragraph.nextSibling;
  var selectAnswer = fieldset.getElementsByClassName("selectAnswer")[0];
  var options = selectAnswer.getElementsByTagName("option");

  // Don't delete if there is only one option remaining.
  // (Note that "Select correct answer" is an option.)
  if (options.length <= 2) {
    window.alert("Cannot delete last remaining answer.");
    return;
  }

  // Delete this answer paragraph.
  answerDiv.removeChild(paragraph);

  // Decrement the letters of all subsequent answers.
  while (nextNode) {
    if (nextNode.nodeType == Node.ELEMENT_NODE) {
       var letterSpan = nextNode.getElementsByClassName("letter")[0];
       letterSpan.textContent = prevLetter(letterSpan.textContent);
    }
    nextNode = nextNode.nextSibling;
  }

  // Remove an option from the correct-answer select menu
  selectAnswer.removeChild(options[options.length-1]);
}

function nextLetter(oldLetter) {
  var newLetter = String.fromCharCode(oldLetter.charCodeAt()+1);
  return newLetter;
}

function prevLetter(oldLetter) {
  var newLetter = String.fromCharCode(oldLetter.charCodeAt()-1);
  return newLetter;
}


// Respond to a selction in the action menu
function actionMenu(actionSelect) {

  // Initialize references to useful elements
  var questionForm = actionSelect.parentNode.parentNode;
  var questionDiv = questionForm.parentNode;

  // Process the selected action
  switch (actionSelect.selectedIndex) {

    // Add a blank problem after this one
    case 1:
    break;

    // Add a blank problem before this one
    case 2:
    break;

    // Create a copy of this question
    case 3:

      // Create new question as a copy of the current one, including
      // current input values,
      // and insert it following the current one.
      var newQuestion = document.createElement("form");
      questionDiv.insertBefore(newQuestion, questionForm.nextSibling);
      newQuestion.setAttribute("onsubmit", "return false;");
      newQuestion.addEventListener("submit", 
                                  function (event) { event.preventDefault(); },
				  false);
      actionSelect.selectedIndex = 0;
      addInputValues(questionForm);
      newQuestion.innerHTML = questionForm.innerHTML;

      // Increment the newly created problem's number as well as
      // the number of all subsequent problems.
      var nextNode = newQuestion;
      do {
        if (nextNode.nodeType == Node.ELEMENT_NODE) {
	  var questionNumSpan = 
	    nextNode.getElementsByClassName("questionNum")[0];
	  questionNumSpan.textContent = Number(questionNumSpan.textContent) + 1;
	}
	nextNode = nextNode.nextSibling;
      } while (nextNode);
    break;

    // Move this question earlier
    case 5:
    break;

    // Move this question later
    case 6:
    break;

    // Delete this question
    case 8:
    break;

    default:
      window.alert("Unrecognized selection " + actionSelect.selectedIndex);
  }
  // Reset the action menu selection
  actionSelect.selectedIndex = 0;
}

// XML encode quotes in a string.
function encodeQuotes(aString) {
  return aString.replace(/\"/g, "&quot;"); // used \" rather than " for Emacs
}

// Replace unescaped $...$ or $$...$$ (LaTeX inline/display math mode markings) 
// with [`...`] or \n>>[``...``]<<\n (PGML math mode markings).
function encodeLaTeXMathModePGML(aString) {
  var regex1 = /(^|[^\\])\$([^]*?)([^\\])\$/g;
  var regex2 = /(^|[^\\])\$\$([^]*?)([^\\])\$\$/g;
  return aString.replace(regex2, '$1\n>>[``$2$3``]<<\n').replace(regex1, '$1[`$2$3`]');
}

// Replace unescaped $...$ with \(...\) (PG math mode markings).
// This is used in, e.g., radio button answers.
function encodeLaTeXMathModePG(aString) {
  var regex = /(^|[^\\])\$([^]*?)([^\\])\$/g;
  return aString.replace(regex, '$1\\($2$3\\)');
}

// Modifies the specified element by including in the element the
// user's current inputs.  For instance, this adds value attributes to
// input/text elements.
function addInputValues(element) {

  // Set the value attribute of every input/text element to its value.
  var inputs = element.getElementsByTagName("input");
  for (var i=0; i<inputs.length; i++) {
    var input = inputs[i];
    if (input.getAttribute("type") == "text") {
      input.setAttribute("value", input.value);    
    }
  }

  // Mark as "selected" the currently selected option in each select control.
  // Note that we must remove any "selected" attribute previously set on
  // a different element.
  var selects = element.getElementsByTagName("select");
  for (var i=0; i<selects.length; i++) {
    var select = selects[i];
    var options = select.options;
    for (var j=0; j<options.length; j++) {
      var option = options[j];
      if (j == select.selectedIndex) {
        option.setAttribute("selected", "selected");
      }
      else if (option.hasAttribute("selected")) {
        option.removeAttribute("selected");
      }
    }
  }

  // Add text within each textarea as a text node of that textarea,
  // skipping the "outBox" textarea if it is present in the list.
  // TODO: Should not be special-casing outBox here.
  textareas = element.getElementsByTagName("textarea");
  for (var i=0; i<textareas.length; i++) {
    var textarea = textareas[i];
    if (textarea.getAttribute("id") != "outBox") {
      textarea.textContent = textarea.value;
    }
  }
}

